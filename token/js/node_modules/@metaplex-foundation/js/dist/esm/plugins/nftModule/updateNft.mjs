import { createUpdateMetadataAccountV2Instruction } from '@metaplex-foundation/mpl-token-metadata';
import isEqual from 'lodash.isequal';
import { NoInstructionsToSendError } from '../../errors/SdkError.mjs';
import { useOperation } from '../../types/Operation.mjs';
import { TransactionBuilder } from '../../utils/TransactionBuilder.mjs';

// Operation
// -----------------

const Key = 'UpdateNftOperation';
const updateNftOperation = useOperation(Key);
// -----------------
// Handler
// -----------------
const updateNftOperationHandler = {
  handle: async (operation, metaplex) => {
    const builder = updateNftBuilder(metaplex, operation.input);

    if (builder.isEmpty()) {
      throw new NoInstructionsToSendError(Key);
    }

    return builder.sendAndConfirm(metaplex, operation.input.confirmOptions);
  }
}; // -----------------
// Builder
// -----------------

const updateNftBuilder = (metaplex, params) => {
  const {
    nft,
    updateAuthority = metaplex.identity()
  } = params;
  const updateInstructionDataWithoutChanges = toInstructionData(nft);
  const updateInstructionData = toInstructionData(nft, params);
  const shouldSendUpdateInstruction = !isEqual(updateInstructionData, updateInstructionDataWithoutChanges); // TODO

  return TransactionBuilder.make() // Update the metadata account.
  .when(shouldSendUpdateInstruction, builder => {
    var _params$updateMetadat;

    return builder.add({
      instruction: createUpdateMetadataAccountV2Instruction({
        metadata: nft.metadataAddress,
        updateAuthority: updateAuthority.publicKey
      }, {
        updateMetadataAccountArgsV2: updateInstructionData
      }),
      signers: [updateAuthority],
      key: (_params$updateMetadat = params.updateMetadataInstructionKey) !== null && _params$updateMetadat !== void 0 ? _params$updateMetadat : 'updateMetadata'
    });
  });
};

const toInstructionData = (nft, input = {}) => {
  var _input$newUpdateAutho, _input$primarySaleHap, _input$isMutable, _input$name, _input$symbol, _input$uri, _input$sellerFeeBasis, _input$creators;

  return {
    updateAuthority: (_input$newUpdateAutho = input.newUpdateAuthority) !== null && _input$newUpdateAutho !== void 0 ? _input$newUpdateAutho : nft.updateAuthorityAddress,
    primarySaleHappened: (_input$primarySaleHap = input.primarySaleHappened) !== null && _input$primarySaleHap !== void 0 ? _input$primarySaleHap : nft.primarySaleHappened,
    isMutable: (_input$isMutable = input.isMutable) !== null && _input$isMutable !== void 0 ? _input$isMutable : nft.isMutable,
    data: {
      name: (_input$name = input.name) !== null && _input$name !== void 0 ? _input$name : nft.name,
      symbol: (_input$symbol = input.symbol) !== null && _input$symbol !== void 0 ? _input$symbol : nft.symbol,
      uri: (_input$uri = input.uri) !== null && _input$uri !== void 0 ? _input$uri : nft.uri,
      sellerFeeBasisPoints: (_input$sellerFeeBasis = input.sellerFeeBasisPoints) !== null && _input$sellerFeeBasis !== void 0 ? _input$sellerFeeBasis : nft.sellerFeeBasisPoints,
      creators: (_input$creators = input.creators) !== null && _input$creators !== void 0 ? _input$creators : nft.creators,
      collection: input.collection === undefined ? nft.collection : input.collection,
      uses: input.uses === undefined ? nft.uses : input.uses
    }
  };
};

export { updateNftBuilder, updateNftOperation, updateNftOperationHandler };
//# sourceMappingURL=updateNft.mjs.map
