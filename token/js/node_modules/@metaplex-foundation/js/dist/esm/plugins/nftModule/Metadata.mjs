import { findMetadataPda } from './pdas.mjs';
import assert from '../../utils/assert.mjs';
import { removeEmptyChars } from '../../utils/common.mjs';
import { toMint } from '../tokenModule/Mint.mjs';
import { toTokenWithMint } from '../tokenModule/Token.mjs';
import { toBigNumber } from '../../types/BigNumber.mjs';
import { amount } from '../../types/Amount.mjs';

const isMetadata = value => typeof value === 'object' && value.model === 'metadata';
function assertMetadata(value) {
  assert(isMetadata(value), `Expected Metadata model`);
}
const toMetadata = (account, json) => ({ ...toLazyMetadata(account),
  lazy: false,
  json
});
const isLazyMetadata = value => typeof value === 'object' && value.model === 'metadata' && value.lazy;
function assertLazyMetadata(value) {
  assert(isLazyMetadata(value), `Expected LazyMetadata model`);
}
const toLazyMetadata = account => {
  var _account$data$data$cr;

  return {
    model: 'metadata',
    lazy: true,
    address: findMetadataPda(account.data.mint),
    mintAddress: account.data.mint,
    updateAuthorityAddress: account.data.updateAuthority,
    name: removeEmptyChars(account.data.data.name),
    symbol: removeEmptyChars(account.data.data.symbol),
    uri: removeEmptyChars(account.data.data.uri),
    isMutable: account.data.isMutable,
    primarySaleHappened: account.data.primarySaleHappened,
    sellerFeeBasisPoints: account.data.data.sellerFeeBasisPoints,
    editionNonce: account.data.editionNonce,
    creators: (_account$data$data$cr = account.data.data.creators) !== null && _account$data$data$cr !== void 0 ? _account$data$data$cr : [],
    tokenStandard: account.data.tokenStandard,
    collection: account.data.collection,
    uses: account.data.uses ? { ...account.data.uses,
      remaining: toBigNumber(account.data.uses.remaining),
      total: toBigNumber(account.data.uses.total)
    } : null
  };
};
const isMintWithMetadata = value => typeof value === 'object' && value.model === 'mintWithMetadata';
function assertMintWithMetadata(value) {
  assert(isMintWithMetadata(value), `Expected MintWithMetadata model`);
}
const toMintWithMetadata = (mintAccount, metadataModel) => {
  const mint = toMint(mintAccount);
  const currency = { ...mint.currency,
    symbol: metadataModel.symbol || 'Token'
  };
  return { ...mint,
    model: 'mintWithMetadata',
    metadata: metadataModel,
    currency,
    supply: amount(mint.supply.basisPoints, currency)
  };
};
const isTokenWithMetadata = value => typeof value === 'object' && value.model === 'tokenWithMetadata';
function assertTokenWithMetadata(value) {
  assert(isTokenWithMetadata(value), `Expected TokenWithMetadata model`);
}
const toTokenWithMetadata = (tokenAccount, mintModel, metadataModel) => {
  const token = toTokenWithMint(tokenAccount, mintModel);
  const currency = { ...token.mint.currency,
    symbol: metadataModel.symbol || 'Token'
  };
  return { ...token,
    model: 'tokenWithMetadata',
    mint: { ...token.mint,
      currency,
      supply: amount(token.mint.supply.basisPoints, currency)
    },
    metadata: metadataModel,
    amount: amount(token.amount.basisPoints, currency),
    delegateAmount: amount(token.delegateAmount.basisPoints, currency)
  };
};

export { assertLazyMetadata, assertMetadata, assertMintWithMetadata, assertTokenWithMetadata, isLazyMetadata, isMetadata, isMintWithMetadata, isTokenWithMetadata, toLazyMetadata, toMetadata, toMintWithMetadata, toTokenWithMetadata };
//# sourceMappingURL=Metadata.mjs.map
