import { createNftOperation } from './createNft.mjs';
import { findMintWithMetadataByAddressOperation } from './findMintWithMetadataByAddress.mjs';
import { findMintWithMetadataByMetadataOperation } from './findMintWithMetadataByMetadata.mjs';
import { findNftByMintOperation } from './findNftByMint.mjs';
import { findNftsByMintListOperation } from './findNftsByMintList.mjs';
import { findNftsByOwnerOperation } from './findNftsByOwner.mjs';
import { findNftsByUpdateAuthorityOperation } from './findNftsByUpdateAuthority.mjs';
import { findNftsByCreatorOperation } from './findNftsByCreator.mjs';
import { findTokenWithMetadataByAddressOperation } from './findTokenWithMetadataByAddress.mjs';
import { findTokenWithMetadataByMetadataOperation } from './findTokenWithMetadataByMetadata.mjs';
import { findTokenWithMetadataByMintOperation } from './findTokenWithMetadataByMint.mjs';
import { loadMetadataOperation } from './loadMetadata.mjs';
import { printNewEditionOperation } from './printNewEdition.mjs';
import { uploadMetadataOperation } from './uploadMetadata.mjs';
import { updateNftOperation } from './updateNft.mjs';
import { loadNftOperation } from './loadNft.mjs';
import { NftBuildersClient } from './NftBuildersClient.mjs';
import { useNftOperation } from './useNft.mjs';
import { Task } from '../../utils/Task.mjs';

class NftClient {
  constructor(metaplex) {
    this.metaplex = metaplex;
  }

  builders() {
    return new NftBuildersClient(this.metaplex);
  }

  create(input) {
    return new Task(async scope => {
      const operation = createNftOperation(input);
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const nft = await this.findByMint(output.mintSigner.publicKey).run(scope);
      return { ...output,
        nft
      };
    });
  }

  findByMint(mint, options) {
    return this.metaplex.operations().getTask(findNftByMintOperation({
      mint,
      ...options
    }));
  }

  findAllByMintList(mints, options) {
    return this.metaplex.operations().getTask(findNftsByMintListOperation({
      mints,
      ...options
    }));
  }

  findAllByOwner(owner, options) {
    return this.metaplex.operations().getTask(findNftsByOwnerOperation({
      owner,
      ...options
    }));
  }

  findAllByUpdateAuthority(updateAuthority, options) {
    return this.metaplex.operations().getTask(findNftsByUpdateAuthorityOperation({
      updateAuthority,
      ...options
    }));
  }

  findAllByCreator(creator, options) {
    return this.metaplex.operations().getTask(findNftsByCreatorOperation({
      creator,
      ...options
    }));
  }

  findMintWithMetadataByAddress(address, options) {
    return this.metaplex.operations().getTask(findMintWithMetadataByAddressOperation({
      address,
      ...options
    }));
  }

  findMintWithMetadataByMetadata(address, options) {
    return this.metaplex.operations().getTask(findMintWithMetadataByMetadataOperation({
      address,
      ...options
    }));
  }

  findTokenWithMetadataByAddress(address, options) {
    return this.metaplex.operations().getTask(findTokenWithMetadataByAddressOperation({
      address,
      ...options
    }));
  }

  findTokenWithMetadataByMetadata(metadataAddress, ownerAddress, options) {
    return this.metaplex.operations().getTask(findTokenWithMetadataByMetadataOperation({
      metadataAddress,
      ownerAddress,
      ...options
    }));
  }

  findTokenWithMetadataByMint(mintAddress, ownerAddress, options) {
    return this.metaplex.operations().getTask(findTokenWithMetadataByMintOperation({
      mintAddress,
      ownerAddress,
      ...options
    }));
  }

  loadMetadata(metadata) {
    return this.metaplex.operations().getTask(loadMetadataOperation({
      metadata
    }));
  }

  loadNft(nft, options = {}) {
    return this.metaplex.operations().getTask(loadNftOperation({
      nft,
      ...options
    }));
  }

  printNewEdition(originalNft, input = {}) {
    return new Task(async scope => {
      const operation = printNewEditionOperation({
        originalNft,
        ...input
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const nft = await this.findByMint(output.mintSigner.publicKey).run(scope);
      return { ...output,
        nft
      };
    });
  }

  uploadMetadata(input) {
    return this.metaplex.operations().getTask(uploadMetadataOperation(input));
  }

  update(nft, input) {
    return new Task(async scope => {
      const operation = updateNftOperation({ ...input,
        nft
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const updatedNft = await this.findByMint(nft.mintAddress).run(scope);
      return { ...output,
        nft: updatedNft
      };
    });
  }

  use(nft, input = {}) {
    return new Task(async scope => {
      const operation = useNftOperation({ ...input,
        nft
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const updatedNft = await this.findByMint(output.mintAddress).run(scope);
      return { ...output,
        nft: updatedNft
      };
    });
  }

}

export { NftClient };
//# sourceMappingURL=NftClient.mjs.map
