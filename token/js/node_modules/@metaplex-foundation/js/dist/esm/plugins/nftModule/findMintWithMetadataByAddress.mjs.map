{"version":3,"file":"findMintWithMetadataByAddress.mjs","sources":["../../../../src/plugins/nftModule/findMintWithMetadataByAddress.ts"],"sourcesContent":["import type { Commitment, PublicKey } from '@solana/web3.js';\nimport { Metaplex } from '@/Metaplex';\nimport { Operation, useOperation, OperationHandler } from '@/types';\nimport {\n  toMintWithMetadata,\n  MintWithMetadata,\n  toLazyMetadata,\n  Metadata,\n  LazyMetadata,\n} from './Metadata';\nimport { toMint, Mint, toMintAccount } from '../tokenModule';\nimport { findMetadataPda } from './pdas';\nimport { parseMetadataAccount } from './accounts';\nimport { DisposableScope } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindMintWithMetadataByAddressOperation' as const;\nexport const findMintWithMetadataByAddressOperation =\n  useOperation<FindMintWithMetadataByAddressOperation>(Key);\nexport type FindMintWithMetadataByAddressOperation = Operation<\n  typeof Key,\n  FindMintWithMetadataByAddressInput,\n  MintWithMetadata | Mint\n>;\n\nexport type FindMintWithMetadataByAddressInput = {\n  address: PublicKey;\n  commitment?: Commitment;\n  loadJsonMetadata?: boolean; // Default: true\n};\n\n// -----------------\n// Handler\n// -----------------\n\nexport const findMintWithMetadataByAddressOperationHandler: OperationHandler<FindMintWithMetadataByAddressOperation> =\n  {\n    handle: async (\n      operation: FindMintWithMetadataByAddressOperation,\n      metaplex: Metaplex,\n      scope: DisposableScope\n    ): Promise<MintWithMetadata | Mint> => {\n      const {\n        address: mintAddress,\n        commitment,\n        loadJsonMetadata = true,\n      } = operation.input;\n      const metadataAddress = findMetadataPda(mintAddress);\n\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts([mintAddress, metadataAddress], commitment);\n      scope.throwIfCanceled();\n\n      const mintAccount = toMintAccount(accounts[0]);\n\n      if (!accounts[1].exists) {\n        return toMint(mintAccount);\n      }\n\n      const metadataAccount = parseMetadataAccount(accounts[1]);\n      let metadataModel: Metadata | LazyMetadata =\n        toLazyMetadata(metadataAccount);\n\n      if (loadJsonMetadata) {\n        metadataModel = await metaplex\n          .nfts()\n          .loadMetadata(metadataModel)\n          .run(scope);\n      }\n\n      return toMintWithMetadata(mintAccount, metadataModel);\n    },\n  };\n"],"names":["Key","findMintWithMetadataByAddressOperation","useOperation","findMintWithMetadataByAddressOperationHandler","handle","operation","metaplex","scope","address","mintAddress","commitment","loadJsonMetadata","input","metadataAddress","findMetadataPda","accounts","rpc","getMultipleAccounts","throwIfCanceled","mintAccount","toMintAccount","exists","toMint","metadataAccount","parseMetadataAccount","metadataModel","toLazyMetadata","nfts","loadMetadata","run","toMintWithMetadata"],"mappings":";;;;;;;AAeA;AACA;AACA;AAEA,MAAMA,GAAG,GAAG,wCAAZ,CAAA;MACaC,sCAAsC,GACjDC,YAAY,CAAyCF,GAAzC,EADP;AAcP;AACA;AACA;AAEO,MAAMG,6CAAuG,GAClH;AACEC,EAAAA,MAAM,EAAE,OACNC,SADM,EAENC,QAFM,EAGNC,KAHM,KAI+B;IACrC,MAAM;AACJC,MAAAA,OAAO,EAAEC,WADL;MAEJC,UAFI;AAGJC,MAAAA,gBAAgB,GAAG,IAAA;KACjBN,GAAAA,SAAS,CAACO,KAJd,CAAA;AAKA,IAAA,MAAMC,eAAe,GAAGC,eAAe,CAACL,WAAD,CAAvC,CAAA;AAEA,IAAA,MAAMM,QAAQ,GAAG,MAAMT,QAAQ,CAC5BU,GADoB,EAEpBC,CAAAA,mBAFoB,CAEA,CAACR,WAAD,EAAcI,eAAd,CAFA,EAEgCH,UAFhC,CAAvB,CAAA;AAGAH,IAAAA,KAAK,CAACW,eAAN,EAAA,CAAA;IAEA,MAAMC,WAAW,GAAGC,aAAa,CAACL,QAAQ,CAAC,CAAD,CAAT,CAAjC,CAAA;;AAEA,IAAA,IAAI,CAACA,QAAQ,CAAC,CAAD,CAAR,CAAYM,MAAjB,EAAyB;MACvB,OAAOC,MAAM,CAACH,WAAD,CAAb,CAAA;AACD,KAAA;;IAED,MAAMI,eAAe,GAAGC,oBAAoB,CAACT,QAAQ,CAAC,CAAD,CAAT,CAA5C,CAAA;AACA,IAAA,IAAIU,aAAsC,GACxCC,cAAc,CAACH,eAAD,CADhB,CAAA;;AAGA,IAAA,IAAIZ,gBAAJ,EAAsB;AACpBc,MAAAA,aAAa,GAAG,MAAMnB,QAAQ,CAC3BqB,IADmB,EAAA,CAEnBC,YAFmB,CAENH,aAFM,CAAA,CAGnBI,GAHmB,CAGftB,KAHe,CAAtB,CAAA;AAID,KAAA;;AAED,IAAA,OAAOuB,kBAAkB,CAACX,WAAD,EAAcM,aAAd,CAAzB,CAAA;AACD,GAAA;AApCH;;;;"}