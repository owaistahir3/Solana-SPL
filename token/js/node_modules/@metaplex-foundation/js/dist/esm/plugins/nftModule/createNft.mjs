import { Keypair } from '@solana/web3.js';
import { createCreateMetadataAccountV2Instruction, createCreateMasterEditionV3Instruction } from '@metaplex-foundation/mpl-token-metadata';
import { findMetadataPda, findMasterEditionV2Pda } from './pdas.mjs';
import { token } from '../../types/Amount.mjs';
import { toUniformVerifiedCreators } from '../../types/Creator.mjs';
import { useOperation } from '../../types/Operation.mjs';
import { TransactionBuilder } from '../../utils/TransactionBuilder.mjs';

// -----------------
// Operation
// -----------------
const Key = 'CreateNftOperation';
const createNftOperation = useOperation(Key);
// -----------------
// Handler
// -----------------
const createNftOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const builder = await createNftBuilder(metaplex, operation.input);
    scope.throwIfCanceled();
    return builder.sendAndConfirm(metaplex, operation.input.confirmOptions);
  }
}; // -----------------
// Builder
// -----------------

const createNftBuilder = async (metaplex, params) => {
  var _params$creators, _params$symbol, _params$collection, _params$uses, _params$isMutable, _params$createMetadat, _params$createMasterE;

  const {
    mint = Keypair.generate(),
    payer = metaplex.identity(),
    updateAuthority = metaplex.identity(),
    owner = metaplex.identity().publicKey,
    tokenAccount,
    mintAuthority = metaplex.identity(),
    freezeAuthority = metaplex.identity().publicKey,
    tokenProgram,
    associatedTokenProgram
  } = params;
  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({
    decimals: 0,
    initialSupply: token(1),
    mint,
    mintAuthority,
    freezeAuthority: freezeAuthority !== null && freezeAuthority !== void 0 ? freezeAuthority : null,
    owner,
    token: tokenAccount,
    payer,
    tokenProgram,
    associatedTokenProgram,
    createMintAccountInstructionKey: params.createMintAccountInstructionKey,
    initializeMintInstructionKey: params.initializeMintInstructionKey,
    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,
    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,
    initializeTokenInstructionKey: params.initializeTokenInstructionKey,
    mintTokensInstructionKey: params.mintTokensInstructionKey
  });
  const {
    tokenAddress
  } = tokenWithMintBuilder.getContext();
  const metadataPda = findMetadataPda(mint.publicKey);
  const masterEditionPda = findMasterEditionV2Pda(mint.publicKey);
  const creators = (_params$creators = params.creators) !== null && _params$creators !== void 0 ? _params$creators : toUniformVerifiedCreators(updateAuthority.publicKey);
  return TransactionBuilder.make().setFeePayer(payer).setContext({
    mintSigner: mint,
    metadataAddress: metadataPda,
    masterEditionAddress: masterEditionPda,
    tokenAddress
  }) // Create the mint and token accounts before minting 1 token to the owner.
  .add(tokenWithMintBuilder) // Create metadata account.
  .add({
    instruction: createCreateMetadataAccountV2Instruction({
      metadata: metadataPda,
      mint: mint.publicKey,
      mintAuthority: mintAuthority.publicKey,
      payer: payer.publicKey,
      updateAuthority: updateAuthority.publicKey
    }, {
      createMetadataAccountArgsV2: {
        data: {
          name: params.name,
          symbol: (_params$symbol = params.symbol) !== null && _params$symbol !== void 0 ? _params$symbol : '',
          uri: params.uri,
          sellerFeeBasisPoints: params.sellerFeeBasisPoints,
          creators,
          collection: (_params$collection = params.collection) !== null && _params$collection !== void 0 ? _params$collection : null,
          uses: (_params$uses = params.uses) !== null && _params$uses !== void 0 ? _params$uses : null
        },
        isMutable: (_params$isMutable = params.isMutable) !== null && _params$isMutable !== void 0 ? _params$isMutable : true
      }
    }),
    signers: [payer, mintAuthority],
    key: (_params$createMetadat = params.createMetadataInstructionKey) !== null && _params$createMetadat !== void 0 ? _params$createMetadat : 'createMetadata'
  }) // Create master edition account (prevents further minting).
  .add({
    instruction: createCreateMasterEditionV3Instruction({
      edition: masterEditionPda,
      mint: mint.publicKey,
      updateAuthority: updateAuthority.publicKey,
      mintAuthority: mintAuthority.publicKey,
      payer: payer.publicKey,
      metadata: metadataPda
    }, {
      createMasterEditionArgs: {
        maxSupply: params.maxSupply === undefined ? 0 : params.maxSupply
      }
    }),
    signers: [payer, mintAuthority, updateAuthority],
    key: (_params$createMasterE = params.createMasterEditionInstructionKey) !== null && _params$createMasterE !== void 0 ? _params$createMasterE : 'createMasterEdition'
  });
};

export { createNftBuilder, createNftOperation, createNftOperationHandler };
//# sourceMappingURL=createNft.mjs.map
