import { toNft } from './Nft.mjs';
import { toOriginalOrPrintEditionAccount } from './accounts.mjs';
import { findMasterEditionV2Pda } from './pdas.mjs';
import { toNftEdition } from './NftEdition.mjs';
import { useOperation } from '../../types/Operation.mjs';
import { toMintAccount } from '../tokenModule/accounts.mjs';
import { toMint } from '../tokenModule/Mint.mjs';

// Operation
// -----------------

const Key = 'LoadNftOperation';
const loadNftOperation = useOperation(Key);
// -----------------
// Handler
// -----------------
const loadNftOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const {
      nft,
      commitment
    } = operation.input;
    const mint = nft.mintAddress;
    const accounts = await metaplex.rpc().getMultipleAccounts([mint, findMasterEditionV2Pda(mint)], commitment);
    scope.throwIfCanceled();
    const mintAccount = toMintAccount(accounts[0]);
    const editionAccount = toOriginalOrPrintEditionAccount(accounts[1]);
    const lazyMetadata = { ...nft,
      model: 'metadata',
      address: nft.metadataAddress
    };
    const metadata = await metaplex.nfts().loadMetadata(lazyMetadata).run(scope);
    scope.throwIfCanceled();
    return toNft(metadata, toMint(mintAccount), toNftEdition(editionAccount));
  }
};

export { loadNftOperation, loadNftOperationHandler };
//# sourceMappingURL=loadNft.mjs.map
