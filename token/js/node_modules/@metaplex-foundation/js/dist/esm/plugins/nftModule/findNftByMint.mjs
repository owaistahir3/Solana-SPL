import { findMetadataPda, findMasterEditionV2Pda } from './pdas.mjs';
import { toMetadataAccount, toOriginalOrPrintEditionAccount } from './accounts.mjs';
import { toNft } from './Nft.mjs';
import { toLazyMetadata } from './Metadata.mjs';
import { toNftEdition } from './NftEdition.mjs';
import { useOperation } from '../../types/Operation.mjs';
import { toMintAccount } from '../tokenModule/accounts.mjs';
import { toMint } from '../tokenModule/Mint.mjs';

// Operation
// -----------------

const Key = 'FindNftByMintOperation';
const findNftByMintOperation = useOperation(Key);
// -----------------
// Handler
// -----------------
const findNftByMintOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const {
      mint,
      commitment
    } = operation.input;
    const accounts = await metaplex.rpc().getMultipleAccounts([mint, findMetadataPda(mint), findMasterEditionV2Pda(mint)], commitment);
    scope.throwIfCanceled();
    const mintAccount = toMintAccount(accounts[0]);
    const metadataAccount = toMetadataAccount(accounts[1]);
    const editionAccount = toOriginalOrPrintEditionAccount(accounts[2]);
    const lazyMetadata = toLazyMetadata(metadataAccount);
    const metadata = await metaplex.nfts().loadMetadata(lazyMetadata).run(scope);
    scope.throwIfCanceled();
    return toNft(metadata, toMint(mintAccount), toNftEdition(editionAccount));
  }
};

export { findNftByMintOperation, findNftByMintOperationHandler };
//# sourceMappingURL=findNftByMint.mjs.map
