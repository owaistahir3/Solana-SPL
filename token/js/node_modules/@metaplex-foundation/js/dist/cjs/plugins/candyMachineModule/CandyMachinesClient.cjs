'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var CandyMachinesBuildersClient = require('./CandyMachinesBuildersClient.cjs');
var createCandyMachine = require('./createCandyMachine.cjs');
var CandyMachineJsonConfigs = require('./CandyMachineJsonConfigs.cjs');
var findCandyMachineByAddress = require('./findCandyMachineByAddress.cjs');
var findCandyMachinesByPublicKeyField = require('./findCandyMachinesByPublicKeyField.cjs');
var findMintedNftsByCandyMachine = require('./findMintedNftsByCandyMachine.cjs');
var insertItemsToCandyMachine = require('./insertItemsToCandyMachine.cjs');
var updateCandyMachine = require('./updateCandyMachine.cjs');
var mintCandyMachine = require('./mintCandyMachine.cjs');
var errors = require('./errors.cjs');
var Task = require('../../utils/Task.cjs');

class CandyMachinesClient {
  constructor(metaplex) {
    this.metaplex = metaplex;
  }

  builders() {
    return new CandyMachinesBuildersClient.CandyMachinesBuildersClient(this.metaplex);
  }

  create(input) {
    return new Task.Task(async scope => {
      const operation = createCandyMachine.createCandyMachineOperation(input);
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const candyMachine = await this.findByAddress(output.candyMachineSigner.publicKey).run(scope);
      return { ...output,
        candyMachine
      };
    });
  }

  createFromJsonConfig(input) {
    const {
      json,
      ...otherInputs
    } = input;
    const configs = CandyMachineJsonConfigs.toCandyMachineConfigsFromJson(json);
    return this.create({ ...otherInputs,
      ...configs
    });
  }

  findAllByWallet(wallet, options) {
    return this.metaplex.operations().getTask(findCandyMachinesByPublicKeyField.findCandyMachinesByPublicKeyFieldOperation({
      type: 'wallet',
      publicKey: wallet,
      ...options
    }));
  }

  findAllByAuthority(authority, options) {
    return this.metaplex.operations().getTask(findCandyMachinesByPublicKeyField.findCandyMachinesByPublicKeyFieldOperation({
      type: 'authority',
      publicKey: authority,
      ...options
    }));
  }

  findByAddress(address, options) {
    return this.metaplex.operations().getTask(findCandyMachineByAddress.findCandyMachineByAddressOperation({
      address,
      ...options
    }));
  }

  findMintedNfts(candyMachine, options) {
    return this.metaplex.operations().getTask(findMintedNftsByCandyMachine.findMintedNftsByCandyMachineOperation({
      candyMachine,
      ...options
    }));
  }

  insertItems(candyMachine, input) {
    return new Task.Task(async scope => {
      const operation = insertItemsToCandyMachine.insertItemsToCandyMachineOperation({
        candyMachine,
        ...input
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const updatedCandyMachine = await this.findByAddress(candyMachine.address).run();
      return {
        candyMachine: updatedCandyMachine,
        ...output
      };
    });
  }

  mint(candyMachine, input = {}) {
    return new Task.Task(async scope => {
      const operation = mintCandyMachine.mintCandyMachineOperation({
        candyMachine,
        ...input
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      let nft;

      try {
        nft = await this.metaplex.nfts().findByMint(output.mintSigner.publicKey).run(scope);
      } catch (error) {
        throw new errors.CandyMachineBotTaxError(this.metaplex.rpc().getSolanaExporerUrl(output.response.signature), error);
      }

      scope.throwIfCanceled();
      const updatedCandyMachine = await this.findByAddress(candyMachine.address).run(scope);
      return {
        nft,
        candyMachine: updatedCandyMachine,
        ...output
      };
    });
  }

  update(candyMachine, input) {
    return new Task.Task(async scope => {
      const output = await this.metaplex.operations().execute(updateCandyMachine.updateCandyMachineOperation({
        candyMachine,
        ...input
      }), scope);
      scope.throwIfCanceled();
      const updatedCandyMachine = await this.findByAddress(candyMachine.address).run();
      return {
        candyMachine: updatedCandyMachine,
        ...output
      };
    });
  }

  updateFromJsonConfig(candyMachine, input) {
    const {
      json,
      ...otherInputs
    } = input;
    const configs = CandyMachineJsonConfigs.toCandyMachineConfigsFromJson(json);
    return this.update(candyMachine, { ...otherInputs,
      ...configs
    });
  }

}

exports.CandyMachinesClient = CandyMachinesClient;
//# sourceMappingURL=CandyMachinesClient.cjs.map
