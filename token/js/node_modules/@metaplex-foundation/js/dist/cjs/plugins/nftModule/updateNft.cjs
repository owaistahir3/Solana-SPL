'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mplTokenMetadata = require('@metaplex-foundation/mpl-token-metadata');
var isEqual = require('lodash.isequal');
var SdkError = require('../../errors/SdkError.cjs');
var Operation = require('../../types/Operation.cjs');
var TransactionBuilder = require('../../utils/TransactionBuilder.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

// Operation
// -----------------

const Key = 'UpdateNftOperation';
const updateNftOperation = Operation.useOperation(Key);
// -----------------
// Handler
// -----------------
const updateNftOperationHandler = {
  handle: async (operation, metaplex) => {
    const builder = updateNftBuilder(metaplex, operation.input);

    if (builder.isEmpty()) {
      throw new SdkError.NoInstructionsToSendError(Key);
    }

    return builder.sendAndConfirm(metaplex, operation.input.confirmOptions);
  }
}; // -----------------
// Builder
// -----------------

const updateNftBuilder = (metaplex, params) => {
  const {
    nft,
    updateAuthority = metaplex.identity()
  } = params;
  const updateInstructionDataWithoutChanges = toInstructionData(nft);
  const updateInstructionData = toInstructionData(nft, params);
  const shouldSendUpdateInstruction = !isEqual__default["default"](updateInstructionData, updateInstructionDataWithoutChanges); // TODO

  return TransactionBuilder.TransactionBuilder.make() // Update the metadata account.
  .when(shouldSendUpdateInstruction, builder => {
    var _params$updateMetadat;

    return builder.add({
      instruction: mplTokenMetadata.createUpdateMetadataAccountV2Instruction({
        metadata: nft.metadataAddress,
        updateAuthority: updateAuthority.publicKey
      }, {
        updateMetadataAccountArgsV2: updateInstructionData
      }),
      signers: [updateAuthority],
      key: (_params$updateMetadat = params.updateMetadataInstructionKey) !== null && _params$updateMetadat !== void 0 ? _params$updateMetadat : 'updateMetadata'
    });
  });
};

const toInstructionData = (nft, input = {}) => {
  var _input$newUpdateAutho, _input$primarySaleHap, _input$isMutable, _input$name, _input$symbol, _input$uri, _input$sellerFeeBasis, _input$creators;

  return {
    updateAuthority: (_input$newUpdateAutho = input.newUpdateAuthority) !== null && _input$newUpdateAutho !== void 0 ? _input$newUpdateAutho : nft.updateAuthorityAddress,
    primarySaleHappened: (_input$primarySaleHap = input.primarySaleHappened) !== null && _input$primarySaleHap !== void 0 ? _input$primarySaleHap : nft.primarySaleHappened,
    isMutable: (_input$isMutable = input.isMutable) !== null && _input$isMutable !== void 0 ? _input$isMutable : nft.isMutable,
    data: {
      name: (_input$name = input.name) !== null && _input$name !== void 0 ? _input$name : nft.name,
      symbol: (_input$symbol = input.symbol) !== null && _input$symbol !== void 0 ? _input$symbol : nft.symbol,
      uri: (_input$uri = input.uri) !== null && _input$uri !== void 0 ? _input$uri : nft.uri,
      sellerFeeBasisPoints: (_input$sellerFeeBasis = input.sellerFeeBasisPoints) !== null && _input$sellerFeeBasis !== void 0 ? _input$sellerFeeBasis : nft.sellerFeeBasisPoints,
      creators: (_input$creators = input.creators) !== null && _input$creators !== void 0 ? _input$creators : nft.creators,
      collection: input.collection === undefined ? nft.collection : input.collection,
      uses: input.uses === undefined ? nft.uses : input.uses
    }
  };
};

exports.updateNftBuilder = updateNftBuilder;
exports.updateNftOperation = updateNftOperation;
exports.updateNftOperationHandler = updateNftOperationHandler;
//# sourceMappingURL=updateNft.cjs.map
