'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var TokenBuildersClient = require('./TokenBuildersClient.cjs');
var createMint = require('./createMint.cjs');
var createToken = require('./createToken.cjs');
var createTokenWithMint = require('./createTokenWithMint.cjs');
var findMintByAddress = require('./findMintByAddress.cjs');
var findTokenByAddress = require('./findTokenByAddress.cjs');
var findTokenWithMintByAddress = require('./findTokenWithMintByAddress.cjs');
var findTokenWithMintByMint = require('./findTokenWithMintByMint.cjs');
var mintTokens = require('./mintTokens.cjs');
var sendTokens = require('./sendTokens.cjs');
var Task = require('../../utils/Task.cjs');

class TokenClient {
  constructor(metaplex) {
    this.metaplex = metaplex;
  }

  builders() {
    return new TokenBuildersClient.TokenBuildersClient(this.metaplex);
  }

  createMint(input = {}) {
    return new Task.Task(async scope => {
      const operation = createMint.createMintOperation(input);
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const mint = await this.findMintByAddress(output.mintSigner.publicKey).run(scope);
      return { ...output,
        mint
      };
    });
  }

  createToken(input) {
    return new Task.Task(async scope => {
      const operation = createToken.createTokenOperation(input);
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const token = await this.findTokenByAddress(output.tokenAddress).run(scope);
      return { ...output,
        token
      };
    });
  }

  createTokenWithMint(input = {}) {
    return new Task.Task(async scope => {
      const operation = createTokenWithMint.createTokenWithMintOperation(input);
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const token = await this.findTokenWithMintByMint({
        mint: output.mintSigner.publicKey,
        address: output.tokenAddress,
        addressType: 'token'
      }).run(scope);
      return { ...output,
        token
      };
    });
  }

  findMintByAddress(address, options) {
    return this.metaplex.operations().getTask(findMintByAddress.findMintByAddressOperation({
      address,
      ...options
    }));
  }

  findTokenByAddress(address, options) {
    return this.metaplex.operations().getTask(findTokenByAddress.findTokenByAddressOperation({
      address,
      ...options
    }));
  }

  findTokenWithMintByAddress(address, options) {
    return this.metaplex.operations().getTask(findTokenWithMintByAddress.findTokenWithMintByAddressOperation({
      address,
      ...options
    }));
  }

  findTokenWithMintByMint(input) {
    return this.metaplex.operations().getTask(findTokenWithMintByMint.findTokenWithMintByMintOperation(input));
  }

  mintTokens(input) {
    return this.metaplex.operations().getTask(mintTokens.mintTokensOperation(input));
  }

  sendTokens(input) {
    return this.metaplex.operations().getTask(sendTokens.sendTokensOperation(input));
  }

}

exports.TokenClient = TokenClient;
//# sourceMappingURL=TokenClient.cjs.map
