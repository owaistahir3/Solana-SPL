'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var web3_js = require('@solana/web3.js');
var mplTokenMetadata = require('@metaplex-foundation/mpl-token-metadata');
var pdas = require('./pdas.cjs');
var Amount = require('../../types/Amount.cjs');
var Creator = require('../../types/Creator.cjs');
var Operation = require('../../types/Operation.cjs');
var TransactionBuilder = require('../../utils/TransactionBuilder.cjs');

// -----------------
// Operation
// -----------------
const Key = 'CreateNftOperation';
const createNftOperation = Operation.useOperation(Key);
// -----------------
// Handler
// -----------------
const createNftOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const builder = await createNftBuilder(metaplex, operation.input);
    scope.throwIfCanceled();
    return builder.sendAndConfirm(metaplex, operation.input.confirmOptions);
  }
}; // -----------------
// Builder
// -----------------

const createNftBuilder = async (metaplex, params) => {
  var _params$creators, _params$symbol, _params$collection, _params$uses, _params$isMutable, _params$createMetadat, _params$createMasterE;

  const {
    mint = web3_js.Keypair.generate(),
    payer = metaplex.identity(),
    updateAuthority = metaplex.identity(),
    owner = metaplex.identity().publicKey,
    tokenAccount,
    mintAuthority = metaplex.identity(),
    freezeAuthority = metaplex.identity().publicKey,
    tokenProgram,
    associatedTokenProgram
  } = params;
  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({
    decimals: 0,
    initialSupply: Amount.token(1),
    mint,
    mintAuthority,
    freezeAuthority: freezeAuthority !== null && freezeAuthority !== void 0 ? freezeAuthority : null,
    owner,
    token: tokenAccount,
    payer,
    tokenProgram,
    associatedTokenProgram,
    createMintAccountInstructionKey: params.createMintAccountInstructionKey,
    initializeMintInstructionKey: params.initializeMintInstructionKey,
    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,
    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,
    initializeTokenInstructionKey: params.initializeTokenInstructionKey,
    mintTokensInstructionKey: params.mintTokensInstructionKey
  });
  const {
    tokenAddress
  } = tokenWithMintBuilder.getContext();
  const metadataPda = pdas.findMetadataPda(mint.publicKey);
  const masterEditionPda = pdas.findMasterEditionV2Pda(mint.publicKey);
  const creators = (_params$creators = params.creators) !== null && _params$creators !== void 0 ? _params$creators : Creator.toUniformVerifiedCreators(updateAuthority.publicKey);
  return TransactionBuilder.TransactionBuilder.make().setFeePayer(payer).setContext({
    mintSigner: mint,
    metadataAddress: metadataPda,
    masterEditionAddress: masterEditionPda,
    tokenAddress
  }) // Create the mint and token accounts before minting 1 token to the owner.
  .add(tokenWithMintBuilder) // Create metadata account.
  .add({
    instruction: mplTokenMetadata.createCreateMetadataAccountV2Instruction({
      metadata: metadataPda,
      mint: mint.publicKey,
      mintAuthority: mintAuthority.publicKey,
      payer: payer.publicKey,
      updateAuthority: updateAuthority.publicKey
    }, {
      createMetadataAccountArgsV2: {
        data: {
          name: params.name,
          symbol: (_params$symbol = params.symbol) !== null && _params$symbol !== void 0 ? _params$symbol : '',
          uri: params.uri,
          sellerFeeBasisPoints: params.sellerFeeBasisPoints,
          creators,
          collection: (_params$collection = params.collection) !== null && _params$collection !== void 0 ? _params$collection : null,
          uses: (_params$uses = params.uses) !== null && _params$uses !== void 0 ? _params$uses : null
        },
        isMutable: (_params$isMutable = params.isMutable) !== null && _params$isMutable !== void 0 ? _params$isMutable : true
      }
    }),
    signers: [payer, mintAuthority],
    key: (_params$createMetadat = params.createMetadataInstructionKey) !== null && _params$createMetadat !== void 0 ? _params$createMetadat : 'createMetadata'
  }) // Create master edition account (prevents further minting).
  .add({
    instruction: mplTokenMetadata.createCreateMasterEditionV3Instruction({
      edition: masterEditionPda,
      mint: mint.publicKey,
      updateAuthority: updateAuthority.publicKey,
      mintAuthority: mintAuthority.publicKey,
      payer: payer.publicKey,
      metadata: metadataPda
    }, {
      createMasterEditionArgs: {
        maxSupply: params.maxSupply === undefined ? 0 : params.maxSupply
      }
    }),
    signers: [payer, mintAuthority, updateAuthority],
    key: (_params$createMasterE = params.createMasterEditionInstructionKey) !== null && _params$createMasterE !== void 0 ? _params$createMasterE : 'createMasterEdition'
  });
};

exports.createNftBuilder = createNftBuilder;
exports.createNftOperation = createNftOperation;
exports.createNftOperationHandler = createNftOperationHandler;
//# sourceMappingURL=createNft.cjs.map
