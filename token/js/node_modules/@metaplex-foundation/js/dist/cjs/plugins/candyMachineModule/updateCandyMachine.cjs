'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isEqual = require('lodash.isequal');
var mplCandyMachine = require('@metaplex-foundation/mpl-candy-machine');
var CandyMachine = require('./CandyMachine.cjs');
var pdas$1 = require('./pdas.cjs');
var Operation = require('../../types/Operation.cjs');
var SdkError = require('../../errors/SdkError.cjs');
var Nft = require('../nftModule/Nft.cjs');
var Amount = require('../../types/Amount.cjs');
var TransactionBuilder = require('../../utils/TransactionBuilder.cjs');
var pdas = require('../nftModule/pdas.cjs');
var program = require('../nftModule/program.cjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);

// Operation
// -----------------

const Key = 'UpdateCandyMachineOperation';
const updateCandyMachineOperation = Operation.useOperation(Key);
// -----------------
// Handler
// -----------------
const updateCandyMachineOperationHandler = {
  async handle(operation, metaplex) {
    const builder = updateCandyMachineBuilder(metaplex, operation.input);

    if (builder.isEmpty()) {
      throw new SdkError.NoInstructionsToSendError(Key);
    }

    return builder.sendAndConfirm(metaplex, operation.input.confirmOptions);
  }

}; // -----------------
// Builder
// -----------------

const updateCandyMachineBuilder = (metaplex, params) => {
  const {
    candyMachine,
    authority = metaplex.identity(),
    payer = metaplex.identity(),
    newAuthority,
    newCollection: newCollectionParam,
    ...updatableFields
  } = params;
  const currentConfigs = CandyMachine.toCandyMachineConfigs(candyMachine);
  const instructionDataWithoutChanges = CandyMachine.toCandyMachineInstructionData(candyMachine.address, currentConfigs);
  const instructionData = CandyMachine.toCandyMachineInstructionData(candyMachine.address, { ...currentConfigs,
    ...updatableFields
  });
  const {
    data,
    wallet,
    tokenMint
  } = instructionData;
  const shouldSendUpdateInstruction = !isEqual__default["default"](instructionData, instructionDataWithoutChanges);
  const shouldSendUpdateAuthorityInstruction = !!newAuthority && !newAuthority.equals(authority.publicKey);
  const newCollection = newCollectionParam && (Nft.isNft(newCollectionParam) || Nft.isLazyNft(newCollectionParam)) ? newCollectionParam.mintAddress : newCollectionParam;
  const sameCollection = newCollection && candyMachine.collectionMintAddress && candyMachine.collectionMintAddress.equals(newCollection);
  const shouldSendSetCollectionInstruction = !!newCollection && !sameCollection;
  const shouldSendRemoveCollectionInstruction = !shouldSendSetCollectionInstruction && newCollection === null && candyMachine.collectionMintAddress !== null;
  const updateInstruction = mplCandyMachine.createUpdateCandyMachineInstruction({
    candyMachine: candyMachine.address,
    authority: authority.publicKey,
    wallet
  }, {
    data
  });

  if (tokenMint) {
    updateInstruction.keys.push({
      pubkey: tokenMint,
      isWritable: false,
      isSigner: false
    });
  } else if (params.price) {
    Amount.assertSameCurrencies(params.price, Amount.SOL);
  }

  return TransactionBuilder.TransactionBuilder.make() // Update data.
  .when(shouldSendUpdateInstruction, builder => {
    var _params$updateInstruc;

    return builder.add({
      instruction: updateInstruction,
      signers: [authority],
      key: (_params$updateInstruc = params.updateInstructionKey) !== null && _params$updateInstruc !== void 0 ? _params$updateInstruc : 'update'
    });
  }) // Update authority.
  .when(shouldSendUpdateAuthorityInstruction, builder => {
    var _params$updateAuthori;

    return builder.add({
      instruction: mplCandyMachine.createUpdateAuthorityInstruction({
        candyMachine: candyMachine.address,
        authority: authority.publicKey,
        wallet: candyMachine.walletAddress
      }, {
        newAuthority: newAuthority
      }),
      signers: [authority],
      key: (_params$updateAuthori = params.updateAuthorityInstructionKey) !== null && _params$updateAuthori !== void 0 ? _params$updateAuthori : 'updateAuthority'
    });
  }) // Set or update collection.
  .when(shouldSendSetCollectionInstruction, builder => {
    var _params$setCollection;

    const collectionMint = newCollection;
    const metadata = pdas.findMetadataPda(collectionMint);
    const edition = pdas.findMasterEditionV2Pda(collectionMint);
    const collectionPda = pdas$1.findCandyMachineCollectionPda(candyMachine.address);
    const collectionAuthorityRecord = pdas.findCollectionAuthorityRecordPda(collectionMint, collectionPda);
    return builder.add({
      instruction: mplCandyMachine.createSetCollectionInstruction({
        candyMachine: candyMachine.address,
        authority: authority.publicKey,
        collectionPda,
        payer: payer.publicKey,
        metadata,
        mint: collectionMint,
        edition,
        collectionAuthorityRecord,
        tokenMetadataProgram: program.TokenMetadataProgram.publicKey
      }),
      signers: [payer, authority],
      key: (_params$setCollection = params.setCollectionInstructionKey) !== null && _params$setCollection !== void 0 ? _params$setCollection : 'setCollection'
    });
  }) // Remove collection.
  .when(shouldSendRemoveCollectionInstruction, builder => {
    var _params$removeCollect;

    const collectionMint = candyMachine.collectionMintAddress;
    const metadata = pdas.findMetadataPda(collectionMint);
    const collectionPda = pdas$1.findCandyMachineCollectionPda(candyMachine.address);
    const collectionAuthorityRecord = pdas.findCollectionAuthorityRecordPda(collectionMint, collectionPda);
    return builder.add({
      instruction: mplCandyMachine.createRemoveCollectionInstruction({
        candyMachine: candyMachine.address,
        authority: authority.publicKey,
        collectionPda,
        metadata,
        mint: collectionMint,
        collectionAuthorityRecord,
        tokenMetadataProgram: program.TokenMetadataProgram.publicKey
      }),
      signers: [authority],
      key: (_params$removeCollect = params.removeCollectionInstructionKey) !== null && _params$removeCollect !== void 0 ? _params$removeCollect : 'removeCollection'
    });
  });
};

exports.updateCandyMachineBuilder = updateCandyMachineBuilder;
exports.updateCandyMachineOperation = updateCandyMachineOperation;
exports.updateCandyMachineOperationHandler = updateCandyMachineOperationHandler;
//# sourceMappingURL=updateCandyMachine.cjs.map
