'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pdas = require('./pdas.cjs');
var assert = require('../../utils/assert.cjs');
var common = require('../../utils/common.cjs');
var Mint = require('../tokenModule/Mint.cjs');
var Token = require('../tokenModule/Token.cjs');
var BigNumber = require('../../types/BigNumber.cjs');
var Amount = require('../../types/Amount.cjs');

const isMetadata = value => typeof value === 'object' && value.model === 'metadata';
function assertMetadata(value) {
  assert["default"](isMetadata(value), `Expected Metadata model`);
}
const toMetadata = (account, json) => ({ ...toLazyMetadata(account),
  lazy: false,
  json
});
const isLazyMetadata = value => typeof value === 'object' && value.model === 'metadata' && value.lazy;
function assertLazyMetadata(value) {
  assert["default"](isLazyMetadata(value), `Expected LazyMetadata model`);
}
const toLazyMetadata = account => {
  var _account$data$data$cr;

  return {
    model: 'metadata',
    lazy: true,
    address: pdas.findMetadataPda(account.data.mint),
    mintAddress: account.data.mint,
    updateAuthorityAddress: account.data.updateAuthority,
    name: common.removeEmptyChars(account.data.data.name),
    symbol: common.removeEmptyChars(account.data.data.symbol),
    uri: common.removeEmptyChars(account.data.data.uri),
    isMutable: account.data.isMutable,
    primarySaleHappened: account.data.primarySaleHappened,
    sellerFeeBasisPoints: account.data.data.sellerFeeBasisPoints,
    editionNonce: account.data.editionNonce,
    creators: (_account$data$data$cr = account.data.data.creators) !== null && _account$data$data$cr !== void 0 ? _account$data$data$cr : [],
    tokenStandard: account.data.tokenStandard,
    collection: account.data.collection,
    uses: account.data.uses ? { ...account.data.uses,
      remaining: BigNumber.toBigNumber(account.data.uses.remaining),
      total: BigNumber.toBigNumber(account.data.uses.total)
    } : null
  };
};
const isMintWithMetadata = value => typeof value === 'object' && value.model === 'mintWithMetadata';
function assertMintWithMetadata(value) {
  assert["default"](isMintWithMetadata(value), `Expected MintWithMetadata model`);
}
const toMintWithMetadata = (mintAccount, metadataModel) => {
  const mint = Mint.toMint(mintAccount);
  const currency = { ...mint.currency,
    symbol: metadataModel.symbol || 'Token'
  };
  return { ...mint,
    model: 'mintWithMetadata',
    metadata: metadataModel,
    currency,
    supply: Amount.amount(mint.supply.basisPoints, currency)
  };
};
const isTokenWithMetadata = value => typeof value === 'object' && value.model === 'tokenWithMetadata';
function assertTokenWithMetadata(value) {
  assert["default"](isTokenWithMetadata(value), `Expected TokenWithMetadata model`);
}
const toTokenWithMetadata = (tokenAccount, mintModel, metadataModel) => {
  const token = Token.toTokenWithMint(tokenAccount, mintModel);
  const currency = { ...token.mint.currency,
    symbol: metadataModel.symbol || 'Token'
  };
  return { ...token,
    model: 'tokenWithMetadata',
    mint: { ...token.mint,
      currency,
      supply: Amount.amount(token.mint.supply.basisPoints, currency)
    },
    metadata: metadataModel,
    amount: Amount.amount(token.amount.basisPoints, currency),
    delegateAmount: Amount.amount(token.delegateAmount.basisPoints, currency)
  };
};

exports.assertLazyMetadata = assertLazyMetadata;
exports.assertMetadata = assertMetadata;
exports.assertMintWithMetadata = assertMintWithMetadata;
exports.assertTokenWithMetadata = assertTokenWithMetadata;
exports.isLazyMetadata = isLazyMetadata;
exports.isMetadata = isMetadata;
exports.isMintWithMetadata = isMintWithMetadata;
exports.isTokenWithMetadata = isTokenWithMetadata;
exports.toLazyMetadata = toLazyMetadata;
exports.toMetadata = toMetadata;
exports.toMintWithMetadata = toMintWithMetadata;
exports.toTokenWithMetadata = toTokenWithMetadata;
//# sourceMappingURL=Metadata.cjs.map
