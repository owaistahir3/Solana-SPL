'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var createNft = require('./createNft.cjs');
var findMintWithMetadataByAddress = require('./findMintWithMetadataByAddress.cjs');
var findMintWithMetadataByMetadata = require('./findMintWithMetadataByMetadata.cjs');
var findNftByMint = require('./findNftByMint.cjs');
var findNftsByMintList = require('./findNftsByMintList.cjs');
var findNftsByOwner = require('./findNftsByOwner.cjs');
var findNftsByUpdateAuthority = require('./findNftsByUpdateAuthority.cjs');
var findNftsByCreator = require('./findNftsByCreator.cjs');
var findTokenWithMetadataByAddress = require('./findTokenWithMetadataByAddress.cjs');
var findTokenWithMetadataByMetadata = require('./findTokenWithMetadataByMetadata.cjs');
var findTokenWithMetadataByMint = require('./findTokenWithMetadataByMint.cjs');
var loadMetadata = require('./loadMetadata.cjs');
var printNewEdition = require('./printNewEdition.cjs');
var uploadMetadata = require('./uploadMetadata.cjs');
var updateNft = require('./updateNft.cjs');
var loadNft = require('./loadNft.cjs');
var NftBuildersClient = require('./NftBuildersClient.cjs');
var useNft = require('./useNft.cjs');
var Task = require('../../utils/Task.cjs');

class NftClient {
  constructor(metaplex) {
    this.metaplex = metaplex;
  }

  builders() {
    return new NftBuildersClient.NftBuildersClient(this.metaplex);
  }

  create(input) {
    return new Task.Task(async scope => {
      const operation = createNft.createNftOperation(input);
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const nft = await this.findByMint(output.mintSigner.publicKey).run(scope);
      return { ...output,
        nft
      };
    });
  }

  findByMint(mint, options) {
    return this.metaplex.operations().getTask(findNftByMint.findNftByMintOperation({
      mint,
      ...options
    }));
  }

  findAllByMintList(mints, options) {
    return this.metaplex.operations().getTask(findNftsByMintList.findNftsByMintListOperation({
      mints,
      ...options
    }));
  }

  findAllByOwner(owner, options) {
    return this.metaplex.operations().getTask(findNftsByOwner.findNftsByOwnerOperation({
      owner,
      ...options
    }));
  }

  findAllByUpdateAuthority(updateAuthority, options) {
    return this.metaplex.operations().getTask(findNftsByUpdateAuthority.findNftsByUpdateAuthorityOperation({
      updateAuthority,
      ...options
    }));
  }

  findAllByCreator(creator, options) {
    return this.metaplex.operations().getTask(findNftsByCreator.findNftsByCreatorOperation({
      creator,
      ...options
    }));
  }

  findMintWithMetadataByAddress(address, options) {
    return this.metaplex.operations().getTask(findMintWithMetadataByAddress.findMintWithMetadataByAddressOperation({
      address,
      ...options
    }));
  }

  findMintWithMetadataByMetadata(address, options) {
    return this.metaplex.operations().getTask(findMintWithMetadataByMetadata.findMintWithMetadataByMetadataOperation({
      address,
      ...options
    }));
  }

  findTokenWithMetadataByAddress(address, options) {
    return this.metaplex.operations().getTask(findTokenWithMetadataByAddress.findTokenWithMetadataByAddressOperation({
      address,
      ...options
    }));
  }

  findTokenWithMetadataByMetadata(metadataAddress, ownerAddress, options) {
    return this.metaplex.operations().getTask(findTokenWithMetadataByMetadata.findTokenWithMetadataByMetadataOperation({
      metadataAddress,
      ownerAddress,
      ...options
    }));
  }

  findTokenWithMetadataByMint(mintAddress, ownerAddress, options) {
    return this.metaplex.operations().getTask(findTokenWithMetadataByMint.findTokenWithMetadataByMintOperation({
      mintAddress,
      ownerAddress,
      ...options
    }));
  }

  loadMetadata(metadata) {
    return this.metaplex.operations().getTask(loadMetadata.loadMetadataOperation({
      metadata
    }));
  }

  loadNft(nft, options = {}) {
    return this.metaplex.operations().getTask(loadNft.loadNftOperation({
      nft,
      ...options
    }));
  }

  printNewEdition(originalNft, input = {}) {
    return new Task.Task(async scope => {
      const operation = printNewEdition.printNewEditionOperation({
        originalNft,
        ...input
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const nft = await this.findByMint(output.mintSigner.publicKey).run(scope);
      return { ...output,
        nft
      };
    });
  }

  uploadMetadata(input) {
    return this.metaplex.operations().getTask(uploadMetadata.uploadMetadataOperation(input));
  }

  update(nft, input) {
    return new Task.Task(async scope => {
      const operation = updateNft.updateNftOperation({ ...input,
        nft
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const updatedNft = await this.findByMint(nft.mintAddress).run(scope);
      return { ...output,
        nft: updatedNft
      };
    });
  }

  use(nft, input = {}) {
    return new Task.Task(async scope => {
      const operation = useNft.useNftOperation({ ...input,
        nft
      });
      const output = await this.metaplex.operations().execute(operation, scope);
      scope.throwIfCanceled();
      const updatedNft = await this.findByMint(output.mintAddress).run(scope);
      return { ...output,
        nft: updatedNft
      };
    });
  }

}

exports.NftClient = NftClient;
//# sourceMappingURL=NftClient.cjs.map
