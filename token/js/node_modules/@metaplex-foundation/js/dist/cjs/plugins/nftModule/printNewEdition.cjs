'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var web3_js = require('@solana/web3.js');
var pdas = require('./pdas.cjs');
var accounts = require('./accounts.cjs');
var Nft = require('./Nft.cjs');
var NftEdition = require('./NftEdition.cjs');
var mplTokenMetadata = require('@metaplex-foundation/mpl-token-metadata');
var Operation = require('../../types/Operation.cjs');
var BigNumber = require('../../types/BigNumber.cjs');
var Amount = require('../../types/Amount.cjs');
var pdas$1 = require('../tokenModule/pdas.cjs');
var TransactionBuilder = require('../../utils/TransactionBuilder.cjs');

// Operation
// -----------------

const Key = 'PrintNewEditionOperation';
const printNewEditionOperation = Operation.useOperation(Key);
// -----------------
// Handler
// -----------------
const printNewEditionOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const builder = await printNewEditionBuilder(metaplex, operation.input);
    scope.throwIfCanceled();
    return builder.sendAndConfirm(metaplex, operation.input.confirmOptions);
  }
}; // -----------------
// Builder
// -----------------

const printNewEditionBuilder = async (metaplex, params) => {
  const {
    newMint = web3_js.Keypair.generate(),
    newMintAuthority = metaplex.identity(),
    newUpdateAuthority = metaplex.identity().publicKey,
    newOwner = metaplex.identity().publicKey,
    newTokenAccount,
    newFreezeAuthority = metaplex.identity().publicKey,
    payer = metaplex.identity(),
    tokenProgram,
    associatedTokenProgram,
    printNewEditionInstructionKey = 'printNewEdition'
  } = params; // Original NFT.

  const originalMint = Nft.isNft(params.originalNft) || Nft.isLazyNft(params.originalNft) ? params.originalNft.mintAddress : params.originalNft;
  const originalMetadataAddress = pdas.findMetadataPda(originalMint);
  const originalEditionAddress = pdas.findMasterEditionV2Pda(originalMint);
  const originalEditionAccount = accounts.toOriginalEditionAccount(await metaplex.rpc().getAccount(originalEditionAddress));
  const originalEdition = NftEdition.toNftOriginalEdition(originalEditionAccount);
  const edition = BigNumber.toBigNumber(originalEdition.supply.addn(1));
  const updatedOriginalEdition = { ...originalEdition,
    supply: edition
  };
  const originalEditionMarkPda = pdas.findEditionMarkerPda(originalMint, edition); // New NFT.

  const newMetadataAddress = pdas.findMetadataPda(newMint.publicKey);
  const newEditionAddress = pdas.findEditionPda(newMint.publicKey);
  const sharedAccounts = {
    newMetadata: newMetadataAddress,
    newEdition: newEditionAddress,
    masterEdition: originalEditionAddress,
    newMint: newMint.publicKey,
    editionMarkPda: originalEditionMarkPda,
    newMintAuthority: newMintAuthority.publicKey,
    payer: payer.publicKey,
    newMetadataUpdateAuthority: newUpdateAuthority,
    metadata: originalMetadataAddress
  };
  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({
    decimals: 0,
    initialSupply: Amount.token(1),
    mint: newMint,
    mintAuthority: newMintAuthority,
    freezeAuthority: newFreezeAuthority !== null && newFreezeAuthority !== void 0 ? newFreezeAuthority : null,
    owner: newOwner,
    token: newTokenAccount,
    payer,
    tokenProgram,
    associatedTokenProgram,
    createMintAccountInstructionKey: params.createMintAccountInstructionKey,
    initializeMintInstructionKey: params.initializeMintInstructionKey,
    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,
    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,
    initializeTokenInstructionKey: params.initializeTokenInstructionKey,
    mintTokensInstructionKey: params.mintTokensInstructionKey
  });
  const {
    tokenAddress
  } = tokenWithMintBuilder.getContext();
  let printNewEditionInstructionWithSigners;

  if (params.via === 'vault') {
    var _params$tokenVaultPro;

    printNewEditionInstructionWithSigners = {
      instruction: mplTokenMetadata.createMintNewEditionFromMasterEditionViaVaultProxyInstruction({ ...sharedAccounts,
        vaultAuthority: params.vaultAuthority.publicKey,
        safetyDepositStore: params.safetyDepositStore,
        safetyDepositBox: params.safetyDepositBox,
        vault: params.vault,
        tokenVaultProgram: (_params$tokenVaultPro = params.tokenVaultProgram) !== null && _params$tokenVaultPro !== void 0 ? _params$tokenVaultPro : new web3_js.PublicKey('vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn')
      }, {
        mintNewEditionFromMasterEditionViaTokenArgs: {
          edition
        }
      }),
      signers: [newMint, newMintAuthority, payer, params.vaultAuthority],
      key: printNewEditionInstructionKey
    };
  } else {
    var _params$originalToken, _params$originalToken2;

    const originalTokenAccountOwner = (_params$originalToken = params.originalTokenAccountOwner) !== null && _params$originalToken !== void 0 ? _params$originalToken : metaplex.identity();
    const originalTokenAccount = (_params$originalToken2 = params.originalTokenAccount) !== null && _params$originalToken2 !== void 0 ? _params$originalToken2 : pdas$1.findAssociatedTokenAccountPda(originalMint, originalTokenAccountOwner.publicKey);
    printNewEditionInstructionWithSigners = {
      instruction: mplTokenMetadata.createMintNewEditionFromMasterEditionViaTokenInstruction({ ...sharedAccounts,
        tokenAccountOwner: originalTokenAccountOwner.publicKey,
        tokenAccount: originalTokenAccount
      }, {
        mintNewEditionFromMasterEditionViaTokenArgs: {
          edition
        }
      }),
      signers: [newMint, newMintAuthority, payer, originalTokenAccountOwner],
      key: printNewEditionInstructionKey
    };
  }

  return TransactionBuilder.TransactionBuilder.make().setFeePayer(payer).setContext({
    mintSigner: newMint,
    metadataAddress: newMetadataAddress,
    editionAddress: newEditionAddress,
    tokenAddress,
    updatedOriginalEdition
  }) // Create the mint and token accounts before minting 1 token to the owner.
  .add(tokenWithMintBuilder) // Mint new edition.
  .add(printNewEditionInstructionWithSigners);
};

exports.printNewEditionBuilder = printNewEditionBuilder;
exports.printNewEditionOperation = printNewEditionOperation;
exports.printNewEditionOperationHandler = printNewEditionOperationHandler;
//# sourceMappingURL=printNewEdition.cjs.map
