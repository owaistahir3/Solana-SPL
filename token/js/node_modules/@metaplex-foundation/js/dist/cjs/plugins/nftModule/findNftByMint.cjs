'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pdas = require('./pdas.cjs');
var accounts$1 = require('./accounts.cjs');
var Nft = require('./Nft.cjs');
var Metadata = require('./Metadata.cjs');
var NftEdition = require('./NftEdition.cjs');
var Operation = require('../../types/Operation.cjs');
var accounts = require('../tokenModule/accounts.cjs');
var Mint = require('../tokenModule/Mint.cjs');

// Operation
// -----------------

const Key = 'FindNftByMintOperation';
const findNftByMintOperation = Operation.useOperation(Key);
// -----------------
// Handler
// -----------------
const findNftByMintOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const {
      mint,
      commitment
    } = operation.input;
    const accounts$2 = await metaplex.rpc().getMultipleAccounts([mint, pdas.findMetadataPda(mint), pdas.findMasterEditionV2Pda(mint)], commitment);
    scope.throwIfCanceled();
    const mintAccount = accounts.toMintAccount(accounts$2[0]);
    const metadataAccount = accounts$1.toMetadataAccount(accounts$2[1]);
    const editionAccount = accounts$1.toOriginalOrPrintEditionAccount(accounts$2[2]);
    const lazyMetadata = Metadata.toLazyMetadata(metadataAccount);
    const metadata = await metaplex.nfts().loadMetadata(lazyMetadata).run(scope);
    scope.throwIfCanceled();
    return Nft.toNft(metadata, Mint.toMint(mintAccount), NftEdition.toNftEdition(editionAccount));
  }
};

exports.findNftByMintOperation = findNftByMintOperation;
exports.findNftByMintOperationHandler = findNftByMintOperationHandler;
//# sourceMappingURL=findNftByMint.cjs.map
