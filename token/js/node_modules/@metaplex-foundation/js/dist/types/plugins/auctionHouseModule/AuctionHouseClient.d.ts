import { Metaplex } from '../../Metaplex';
import { Signer } from '../../types';
import { Task } from '../../utils';
import { PublicKey } from '@solana/web3.js';
import { AuctionHouse } from './AuctionHouse';
import { CreateListingInput, CreateListingOutput } from './createListing';
import { FindListingByAddressInput } from './findListingByAddress';
import { LazyListing, Listing } from './Listing';
import { LoadListingInput } from './loadListing';
import { CreateBidInput, CreateBidOutput } from './createBid';
import { FindBidByAddressInput } from './findBidByAddress';
import { Bid, LazyBid } from './Bid';
import { LoadBidInput } from './loadBid';
declare type WithoutAH<T> = Omit<T, 'auctionHouse' | 'auctioneerAuthority'>;
export declare class AuctionHouseClient {
    protected readonly metaplex: Metaplex;
    protected readonly auctionHouse: AuctionHouse;
    protected readonly auctioneerAuthority?: Signer | undefined;
    constructor(metaplex: Metaplex, auctionHouse: AuctionHouse, auctioneerAuthority?: Signer | undefined);
    list(input: WithoutAH<CreateListingInput>): Task<CreateListingOutput & {
        listing: Listing;
    }>;
    findListingByAddress(address: PublicKey, options?: Omit<FindListingByAddressInput, 'address' | 'auctionHouse'>): Task<Readonly<{
        model: "listing";
        lazy: false;
        auctionHouse: Readonly<{
            model: "auctionHouse";
            address: import("../../types").Pda;
            creatorAddress: PublicKey;
            authorityAddress: PublicKey;
            treasuryMint: Readonly<{
                model: "mint";
                address: PublicKey;
                mintAuthorityAddress: import("../../utils").Option<PublicKey>;
                freezeAuthorityAddress: import("../../utils").Option<PublicKey>;
                decimals: number;
                supply: import("../../types").SplTokenAmount;
                isWrappedSol: boolean;
                currency: import("../../types").SplTokenCurrency;
            }> | import("..").MintWithMetadata;
            feeAccountAddress: import("../../types").Pda;
            treasuryAccountAddress: import("../../types").Pda;
            feeWithdrawalDestinationAddress: PublicKey;
            treasuryWithdrawalDestinationAddress: PublicKey;
            sellerFeeBasisPoints: number;
            requiresSignOff: boolean;
            canChangeSalePrice: boolean;
            isNative: boolean;
        }>;
        token: import("..").TokenWithMetadata;
        tradeStateAddress: import("../../types").Pda;
        sellerAddress: PublicKey;
        bookkeeperAddress: import("../../utils").Option<PublicKey>;
        receiptAddress: import("../../utils").Option<import("../../types").Pda>;
        purchaseReceiptAddress: import("../../utils").Option<PublicKey>;
        price: import("../../types").SplTokenAmount | import("../../types").SolAmount;
        tokens: import("../../types").SplTokenAmount;
        createdAt: import("../../types").DateTime;
        canceledAt: import("../../utils").Option<import("../../types").DateTime>;
    }>, []>;
    loadListing(lazyListing: LazyListing, options?: Omit<LoadListingInput, 'lazyListing'>): Task<Listing>;
    bid(input: WithoutAH<CreateBidInput>): Task<CreateBidOutput & {
        bid: Bid;
    }>;
    findBidByAddress(address: PublicKey, options?: Omit<FindBidByAddressInput, 'address' | 'auctionHouse'>): Task<Readonly<{
        model: "bid";
        lazy: false;
        auctionHouse: Readonly<{
            model: "auctionHouse";
            address: import("../../types").Pda;
            creatorAddress: PublicKey;
            authorityAddress: PublicKey;
            treasuryMint: Readonly<{
                model: "mint";
                address: PublicKey;
                mintAuthorityAddress: import("../../utils").Option<PublicKey>;
                freezeAuthorityAddress: import("../../utils").Option<PublicKey>;
                decimals: number;
                supply: import("../../types").SplTokenAmount;
                isWrappedSol: boolean;
                currency: import("../../types").SplTokenCurrency;
            }> | import("..").MintWithMetadata;
            feeAccountAddress: import("../../types").Pda;
            treasuryAccountAddress: import("../../types").Pda;
            feeWithdrawalDestinationAddress: PublicKey;
            treasuryWithdrawalDestinationAddress: PublicKey;
            sellerFeeBasisPoints: number;
            requiresSignOff: boolean;
            canChangeSalePrice: boolean;
            isNative: boolean;
        }>;
        tradeStateAddress: import("../../types").Pda;
        buyerAddress: PublicKey;
        bookkeeperAddress: import("../../utils").Option<PublicKey>;
        receiptAddress: import("../../utils").Option<import("../../types").Pda>;
        purchaseReceiptAddress: import("../../utils").Option<PublicKey>;
        price: import("../../types").SplTokenAmount | import("../../types").SolAmount;
        tokens: import("../../types").SplTokenAmount;
        createdAt: import("../../types").DateTime;
        canceledAt: import("../../utils").Option<import("../../types").DateTime>;
    } & {
        isPublic: false;
        token: import("..").TokenWithMetadata;
    }> | Readonly<{
        model: "bid";
        lazy: false;
        auctionHouse: Readonly<{
            model: "auctionHouse";
            address: import("../../types").Pda;
            creatorAddress: PublicKey;
            authorityAddress: PublicKey;
            treasuryMint: Readonly<{
                model: "mint";
                address: PublicKey;
                mintAuthorityAddress: import("../../utils").Option<PublicKey>;
                freezeAuthorityAddress: import("../../utils").Option<PublicKey>;
                decimals: number;
                supply: import("../../types").SplTokenAmount;
                isWrappedSol: boolean;
                currency: import("../../types").SplTokenCurrency;
            }> | import("..").MintWithMetadata;
            feeAccountAddress: import("../../types").Pda;
            treasuryAccountAddress: import("../../types").Pda;
            feeWithdrawalDestinationAddress: PublicKey;
            treasuryWithdrawalDestinationAddress: PublicKey;
            sellerFeeBasisPoints: number;
            requiresSignOff: boolean;
            canChangeSalePrice: boolean;
            isNative: boolean;
        }>;
        tradeStateAddress: import("../../types").Pda;
        buyerAddress: PublicKey;
        bookkeeperAddress: import("../../utils").Option<PublicKey>;
        receiptAddress: import("../../utils").Option<import("../../types").Pda>;
        purchaseReceiptAddress: import("../../utils").Option<PublicKey>;
        price: import("../../types").SplTokenAmount | import("../../types").SolAmount;
        tokens: import("../../types").SplTokenAmount;
        createdAt: import("../../types").DateTime;
        canceledAt: import("../../utils").Option<import("../../types").DateTime>;
    } & {
        isPublic: true;
        mint: import("..").MintWithMetadata;
    }>, []>;
    loadBid(lazyBid: LazyBid, options?: Omit<LoadBidInput, 'lazyBid'>): Task<Bid>;
    protected addAH<T>(input: WithoutAH<T>): T;
}
export {};
