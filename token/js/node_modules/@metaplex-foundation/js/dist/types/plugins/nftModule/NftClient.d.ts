import { PublicKey } from '@solana/web3.js';
import type { Metaplex } from '../../Metaplex';
import { Task } from '../../utils';
import { LazyMetadata, Metadata } from './Metadata';
import { LazyNft, Nft } from './Nft';
import { CreateNftInput, CreateNftOutput } from './createNft';
import { FindMintWithMetadataByAddressInput } from './findMintWithMetadataByAddress';
import { FindMintWithMetadataByMetadataInput } from './findMintWithMetadataByMetadata';
import { FindNftByMintInput } from './findNftByMint';
import { FindNftsByMintListInput } from './findNftsByMintList';
import { FindNftsByOwnerInput } from './findNftsByOwner';
import { FindNftsByUpdateAuthorityInput } from './findNftsByUpdateAuthority';
import { FindNftsByCreatorInput } from './findNftsByCreator';
import { FindTokenWithMetadataByAddressInput } from './findTokenWithMetadataByAddress';
import { FindTokenWithMetadataByMetadataInput } from './findTokenWithMetadataByMetadata';
import { FindTokenWithMetadataByMintInput } from './findTokenWithMetadataByMint';
import { PrintNewEditionOutput, PrintNewEditionSharedInput, PrintNewEditionViaInput } from './printNewEdition';
import { UploadMetadataInput, UploadMetadataOutput } from './uploadMetadata';
import { UpdateNftInput, UpdateNftOutput } from './updateNft';
import { LoadNftInput } from './loadNft';
import { NftBuildersClient } from './NftBuildersClient';
import { UseNftInput, UseNftOutput } from './useNft';
export declare class NftClient {
    protected readonly metaplex: Metaplex;
    constructor(metaplex: Metaplex);
    builders(): NftBuildersClient;
    create(input: CreateNftInput): Task<CreateNftOutput & {
        nft: Nft;
    }>;
    findByMint(mint: PublicKey, options?: Omit<FindNftByMintInput, 'mint'>): Task<Nft>;
    findAllByMintList(mints: PublicKey[], options?: Omit<FindNftsByMintListInput, 'mints'>): Task<(Nft | LazyNft | null)[], []>;
    findAllByOwner(owner: PublicKey, options?: Omit<FindNftsByOwnerInput, 'owner'>): Task<(Nft | LazyNft)[], []>;
    findAllByUpdateAuthority(updateAuthority: PublicKey, options?: Omit<FindNftsByUpdateAuthorityInput, 'updateAuthority'>): Task<(Nft | LazyNft)[], []>;
    findAllByCreator(creator: PublicKey, options?: Omit<FindNftsByCreatorInput, 'creator'>): Task<(Nft | LazyNft)[], []>;
    findMintWithMetadataByAddress(address: PublicKey, options?: Omit<FindMintWithMetadataByAddressInput, 'address'>): Task<Readonly<{
        model: "mint";
        address: PublicKey;
        mintAuthorityAddress: import("../../utils").Option<PublicKey>;
        freezeAuthorityAddress: import("../../utils").Option<PublicKey>;
        decimals: number;
        supply: import("../..").SplTokenAmount;
        isWrappedSol: boolean;
        currency: import("../..").SplTokenCurrency;
    }> | import("./Metadata").MintWithMetadata, []>;
    findMintWithMetadataByMetadata(address: PublicKey, options?: Omit<FindMintWithMetadataByMetadataInput, 'address'>): Task<import("./Metadata").MintWithMetadata, []>;
    findTokenWithMetadataByAddress(address: PublicKey, options?: Omit<FindTokenWithMetadataByAddressInput, 'address'>): Task<import("..").TokenWithMint | import("./Metadata").TokenWithMetadata, []>;
    findTokenWithMetadataByMetadata(metadataAddress: PublicKey, ownerAddress: PublicKey, options?: Omit<FindTokenWithMetadataByMetadataInput, 'metadataAddress' | 'ownerAddress'>): Task<import("./Metadata").TokenWithMetadata, []>;
    findTokenWithMetadataByMint(mintAddress: PublicKey, ownerAddress: PublicKey, options?: Omit<FindTokenWithMetadataByMintInput, 'metadataAddress' | 'ownerAddress'>): Task<import("..").TokenWithMint | import("./Metadata").TokenWithMetadata, []>;
    loadMetadata(metadata: LazyMetadata): Task<Metadata>;
    loadNft(nft: LazyNft, options?: Omit<LoadNftInput, 'nft'>): Task<Nft>;
    printNewEdition(originalNft: Nft | LazyNft | PublicKey, input?: Omit<PrintNewEditionSharedInput, 'originalNft'> & PrintNewEditionViaInput): Task<PrintNewEditionOutput & {
        nft: Nft;
    }>;
    uploadMetadata(input: UploadMetadataInput): Task<UploadMetadataOutput>;
    update(nft: Nft | LazyNft, input: Omit<UpdateNftInput, 'nft'>): Task<UpdateNftOutput & {
        nft: Nft;
    }>;
    use(nft: Nft | LazyNft | PublicKey, input?: Omit<UseNftInput, 'nft'>): Task<UseNftOutput & {
        nft: Nft;
    }>;
}
